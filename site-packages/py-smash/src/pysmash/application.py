import atexit
import inspect
import logging
import os
import sys
from contextlib import contextmanager
from io import StringIO
from typing import Optional

import XCore

current_file = os.path.abspath(sys.argv[0] if __name__ == '__main__' else __file__)
current_dir = os.path.dirname(current_file)
bin_dir = os.path.dirname(os.path.abspath(XCore.__file__))


logger = logging.getLogger(__name__)
logger.debug("Importing %s", __name__)


def get_ui_app_safe():
	""" Returns UI application IF already created, otherwise None

	This is a way to detect a UI context

	:return: returns UI app *raw* object or None
	:rtype: UIApplication
	"""
	try:
		import XCoreUI
		the_raw_uiapp = XCoreUI.GetUIApp()
		if the_raw_uiapp is not None:
			return the_raw_uiapp
	except ImportError:
		pass
	return None


def get_app_safe() -> Optional[XCore.Application]:
	""" Returns any kind of application IF already created, otherwise None

	Notice that this also returns in a UI context

	WARNING: bool(XCore.Application) == False

	:return: returns generic app *raw* object or None
	:rtype: Application
	"""
	the_raw_app = XCore.GetApp()
	if the_raw_app is not None:
		return the_raw_app
	return None


def run_application(*, command=None, include=None, exclude=None, close_at_exit=True) -> Optional[XCore.Application]:
	""" creates and starts an application instance from a stand-alone python interpreter

	TODO: add command, include and exclude lists

	- Parses command core command line options
	- Creates and initialize all plugins
	- Loads preferences file
	- Post-Initializes plugins
	- Creates new document
	- Process command line options


	:raises RuntimeError: [description]
	:return: [description]
	:rtype: [type]
	"""

	theapp = get_app_safe()
	if theapp is not None:
		raise RuntimeError("Application %s already started. Cannot run a new instance without quitting first." % theapp.ApplicationName)

	theapp = XCore.GetOrCreateConsoleApp(
		app_name=f"{__name__}",  # uses name for preference folder
		init_path=bin_dir,
		black_list=["CPythonPlugin", ] # TODO: Now CPlugin Decriptions list but should be CPlugin class names instead! Accept blobs!!!
	)

	assert theapp == get_app_safe(), "Expected single application"

	if close_at_exit:
		atexit.register(close_application)

	return theapp


def close_application():
	""" Stops and destroys application
	WARNING: DO NOT CALL DIRECTLY!
	"""
	try:
		logger.debug("Application CLOSING...")
		if get_app_safe() is not None: # WARNING: bool(app) is False!!!
			if not XCore.FinalizeConsoleApp():
				log.error("Something went wrong while finalizing Console")
			# TODO: What about get_app_safe().Quit(False) ???
	except Exception: # pylint: disable=broad-except
		logger.exception("Aplication FAILED to close")
	finally:
		logger.debug("Application CLOSED")


def print_app_info(theapp=None):
	""" Prints to the stdout, current's application information

	"""
	stream = StringIO()

	if theapp is None:
		theapp = get_app_safe()

	# TODO: get all property values into json-like and add a couple of them by hand
	if theapp is not None:
		print( "{:=^50s}".format(" Current Running Application "), file=stream)
		names = sorted([name for name, _ in inspect.getmembers(XCore.Application, lambda o: isinstance(o, property))])
		LAYOUT = "{:10s} : {:10s}"
		for name in names:
			print( LAYOUT.format(name, repr(getattr(theapp, name))), file=stream)

		print( LAYOUT.format(
			"ignore CLI?", "Yes" if theapp.IgnoreProcessCommandLineOptions else "No"), file=stream)
		print( LAYOUT.format(
			"has UI?:",  "Yes" if theapp.Frame is not None else "No"), file=stream)
		print( LAYOUT.format("Document", theapp.Document.DumpTree()), file=stream)
		print(  "{:=^50s}".format(""), file=stream)
	else:
		print( "No application available", file=stream)

	print(stream.getvalue())


@contextmanager
def managed_application(**kwargs) -> Optional[XCore.Application]:
	kwargs['close_at_exit'] = False
	app = run_application(**kwargs)
	try:
		yield app
	finally:
		close_application()
